{"version":3,"sources":["predictable/utils.js","predictable/predictableMethods.js","predictable/polyfill.js","predictable/predictable.js","words.js","App.js","serviceWorker.js","index.js"],"names":["generateRandomId","Math","random","toString","substring","dataAttribute","select","predictableContainer","concat","result","clearResults","resultsList","innerHTML","predictableMethods","getInput","selector","createResultsList","renderResults","container","position","element","destination","document","createElement","setAttribute","insertAdjacentElement","insertSuggestion","dataSrc","resultItem","length","resultValue","value","content","match","appendChild","getSelection","predictableContainerId","editor","callback","resultsValues","results","getElementById","addEventListener","tabListener","e","key","firstChild","data","event","context","matches","list","map","record","selection","find","resValue","getAttribute","removeEventListener","CustomEventPolyfill","params","bubbles","cancelable","detail","undefined","evt","createEvent","initCustomEvent","prototype","window","Event","Polyfill","CustomEventWrapper","CustomEvent","initElementClosestPolyfill","Element","msMatchesSelector","webkitMatchesSelector","closest","s","el","this","parentElement","parentNode","nodeType","Predictable","options","_this","Object","classCallCheck","lookupSuggestions","currentText","suggestion","startsWith","renderSuggestions","suggestionsData","source","text","textContent","queryValue","getData","triggerCondition","sensitivity","replace","predictableEventHandler","dispatchEvent","input","selected","onTabPress","view","getMatchingSuggestion","then","suggestions","getAllSuggestions","editorId","active","cache","suggestionText","_initPredictable","_this2","Promise","resolve","allSuggestions","filter","index","push","firstSuggestion","slice","words","App","props","possibleConstructorReturn","getPrototypeOf","call","editorContainer","React","createRef","preventTabDefault","preventDefault","getLastWordCoordinates","anchorNode","previousRange","getRangeAt","lastWordOffset","getLastWordOffset","getLastWord","range","createRange","setStart","setEnd","collapse","shadowNode","id","createTextNode","insertNode","removeAllRanges","addRange","_shadowNode$getBoundi","getBoundingClientRect","top","left","normalize","removeChild","selectedElement","split","lastWordOfRange","trim","isCaretAtEnd","selectionRange","temporaryRange","caretEndPosition","rangeCount","cloneRange","selectNodeContents","startContainer","startOffset","endContainer","endOffset","insertTextAtCursor","deleteContents","placeCaretAtEnd","state","mediumEditor","font","fontSize","letterSpacing","MediumEditor","current","placeholder","toolbar","autoLink","imageDragging","disableExtraSpaces","style","display","_this2$getLastWordCoo","cssText","_ref","incompleteText","_incompleteText","autocompleteText","querySelector","react_default","a","className","ref","Component","Boolean","location","hostname","ReactDOM","render","src_App","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.67575a16.chunk.js","sourcesContent":["export const generateRandomId = () => Math.random().toString( 36 ).substring( 2, 4 );","import { generateRandomId } from './utils';\n\nconst dataAttribute = 'data-result';\nconst select = {\n    predictableContainer: `${ generateRandomId() }-${ generateRandomId() }`,\n    result: `${ generateRandomId() }-${ generateRandomId() }`\n};\n\nconst getContent = (selector) => selector;\n\nconst createResultsList = (renderResults) => {\n    const { container, position, element, destination } = renderResults;\n    const resultsList = document.createElement( element );\n    resultsList.setAttribute( 'id', select.predictableContainer );\n\n    if ( container ) {\n        container( resultsList );\n    }\n\n    destination.insertAdjacentElement( position, resultsList );\n    return resultsList;\n};\n\nconst insertSuggestion = (resultsList, dataSrc, resultItem) => {\n    if ( dataSrc.length > 0 ) {\n        const result = document.createElement( resultItem.element );\n        const resultValue = dataSrc[ 0 ].value;\n        result.setAttribute( dataAttribute, resultValue );\n        result.setAttribute( 'id', select.result );\n        result.setAttribute( 'class', 'predictable__suggestion' );\n        result.setAttribute( 'style', 'white-space: nowrap' );\n        resultItem.content ? resultItem.content( dataSrc[ 0 ], result )\n            : ( result.innerHTML = dataSrc[ 0 ].match || dataSrc[ 0 ] );\n        resultsList.appendChild( result );\n    }\n};\n\nconst clearResults = resultsList => ( resultsList.innerHTML = '' );\n\nconst getSelection = (predictableContainerId, editor, resultsList, callback, resultsValues) => {\n    const results = document.getElementById( select.result );\n    const predictableContainer = document.getElementById( predictableContainerId );\n\n    if ( results ) {\n        document.addEventListener( 'keydown', tabListener );\n    }\n\n    function tabListener(e) {\n        if ( e.key === 'Tab' &&\n            predictableContainer.firstChild &&\n            predictableContainer.firstChild.firstChild.data !== ''\n        ) {\n            callback( {\n                event: e,\n                context: editor.innerHTML,\n                matches: resultsValues.matches,\n                results: resultsValues.list.map( record => record.value ),\n                selection: resultsValues.list.find( value => {\n                    const resValue = value.value;\n                    return resValue === results.getAttribute( dataAttribute );\n                } ),\n            } );\n\n            clearResults( resultsList );\n            document.removeEventListener( 'keyup', tabListener );\n        }\n    }\n};\n\nexport const predictableMethods = {\n    getInput: getContent,\n    createResultsList,\n    insertSuggestion,\n    clearResults,\n    getSelection,\n};\n\n","// Refs: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\nconst CustomEventPolyfill = (event, params) => {\n  params = params || { bubbles: false, cancelable: false, detail: undefined };\n  const evt = document.createEvent(\"CustomEvent\");\n  evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n  return evt;\n};\nCustomEventPolyfill.prototype = window.Event.prototype;\n\nconst CustomEventWrapper =\n  (typeof window.CustomEvent === \"function\" && window.CustomEvent) || CustomEventPolyfill;\n\nconst initElementClosestPolyfill = () => {\n  // Element.prototype.closest\n  // Refs: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n  if (!Element.prototype.matches) {\n    Element.prototype.matches =\n      Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n  }\n  if (!Element.prototype.closest) {\n    Element.prototype.closest = function(s) {\n      let el = this;\n      do {\n        if (el.matches(s)) {\n          return el;\n        }\n        el = el.parentElement || el.parentNode;\n      } while (el !== null && el.nodeType === 1);\n      return null;\n    };\n  }\n};\n\nexport const Polyfill = {\n  CustomEventWrapper,\n  initElementClosestPolyfill,\n};\n","import { predictableMethods } from './predictableMethods';\nimport { Polyfill } from './polyfill';\n\nexport default class Predictable {\n    constructor(options) {\n        this.editorId = options.editorId;\n        this.predictableContainerId = options.predictableContainerId;\n        this.editor = options.editor;\n        this.active = false;\n        this.data = {\n            // Data for suggested phrases can be obtained in numerous ways. E.g. a single static source can be used,\n            // or a function can be passed to hydrate initial suggestions from a list before switching to a dynamic\n            // data source.\n            source: () => ( typeof options.data.source === 'function' ? options.data.source() : options.data.source ),\n            cache: false\n        };\n        this.context = options.context;\n        this.sensitivity = options.sensitivity || 3;\n        this.predictableContainer = {\n            view: predictableMethods.createResultsList( {\n                container: options.predictableContainer && options.predictableContainer.container\n                    ? options.predictableContainer.container\n                    : false,\n                destination: options.editor,\n                position: 'afterend',\n                element: 'div',\n            } ),\n        };\n        this.suggestionText = {\n            content: options.suggestionText && options.suggestionText.content ? options.suggestionText.content : false,\n            element: 'span'\n        };\n        this.onTabPress = options.onTabPress;\n        this.suggestionsData = options.suggestionsData;\n        this._initPredictable();\n    }\n\n    _initPredictable() {\n        this.suggestionsData = this.data.source();\n        this.renderSuggestions();\n\n        Polyfill.initElementClosestPolyfill();\n    }\n\n    lookupSuggestions = (currentText, suggestion) => {\n        // Use `startsWith` method to ensure that only predictions exactly matching the currently typed word\n        // are rendered. Otherwise, the prediction container's visual alignment will be thrown off.\n        if ( suggestion.startsWith( currentText ) ) {\n            return suggestion;\n        }\n    };\n\n    getMatchingSuggestion(data) {\n        return new Promise( resolve => {\n            const allSuggestions = [];\n            data.filter( (suggestion, index) => {\n                const match = this.lookupSuggestions( this.queryValue, suggestion );\n                if ( match ) {\n                    allSuggestions.push( {\n                        index,\n                        match, value: suggestion\n                    } );\n                }\n\n                return allSuggestions;\n            } );\n\n            const firstSuggestion = allSuggestions.slice( 0, 1 );\n\n            predictableMethods.insertSuggestion( this.predictableContainer.view, allSuggestions, this.suggestionText );\n\n            return resolve( {\n                matches: allSuggestions.length,\n                list: firstSuggestion\n            } );\n        } );\n    }\n\n    renderSuggestions = () => {\n        const getAllSuggestions = (e) => {\n            const text = this.editor.textContent;\n            const currentText = ( this.queryValue =\n                this.context && this.context.getData ? this.context.getData( text ) : text );\n            const triggerCondition = ( currentText\n                ? currentText.length > this.sensitivity && currentText.replace( / /g, '' ).length\n                : '' );\n            const predictableEventHandler = (e, results) => {\n                this.editor.dispatchEvent(\n                    new Polyfill.CustomEventWrapper( 'Predictable', {\n                        bubbles: true,\n                        detail: {\n                            event: e,\n                            input: text,\n                            context: currentText,\n                            matches: results ? results.matches : null,\n                            results: results ? results.list : null,\n                        },\n                        cancelable: true,\n                    } ),\n                );\n            };\n\n            const selected = this.onTabPress;\n            const resultsList = this.predictableContainer.view;\n            const clearResults = predictableMethods.clearResults( resultsList );\n\n            if ( triggerCondition ) {\n                this.getMatchingSuggestion( this.suggestionsData )\n                    .then( suggestions => {\n                        predictableEventHandler( e, suggestions );\n\n                        if ( selected ) {\n                            predictableMethods.getSelection(\n                                this.predictableContainerId,\n                                this.editor,\n                                resultsList,\n                                selected,\n                                suggestions );\n                        }\n                    } );\n            } else {\n                predictableEventHandler( e );\n                predictableMethods.clearResults( this.predictableContainer.view );\n            }\n\n        };\n\n        this.editor.addEventListener(\n            'keyup', (e) => {\n                this.suggestionsData = this.data.source();\n                getAllSuggestions( e )\n            }\n        );\n    }\n}\n","export const words = ['safe and sound', 'patients leg was broken and needed surgery'];","import React, { Component } from 'react';\nimport MediumEditor from 'medium-editor';\nimport Predictable from './predictable/predictable';\nimport { generateRandomId } from './predictable/utils';\nimport { words } from './words';\n\nclass App extends Component {\n    editorContainer = React.createRef();\n\n    constructor(props) {\n        super( props );\n        this.state = {\n            predictableContainerId: `${ generateRandomId() }-${ generateRandomId() }`,\n            editorId: `${ generateRandomId() }-${ generateRandomId() }`,\n            mediumEditor: null,\n            font: 'Arial, serif!important',\n            fontSize: '16.63px!important',\n            letterSpacing: '0!important'\n        };\n    }\n\n    preventTabDefault = (e) => {\n        const { key } = e;\n\n        if ( key && key === 'Tab' ) {\n            e.preventDefault();\n        }\n/*\n        // TODO: Use control key + up/down to cycle through multiple suggestions.\n        if ( e.ctrlKey && ( key === 'ArrowUp' || key === 'ArrowDown' ) ) {\n            e.preventDefault();\n        }\n\n */\n    };\n\n    componentDidMount() {\n        new MediumEditor(\n            this.editorContainer.current,\n            {\n                placeholder: {\n                    text: 'Start writing...'\n                },\n                toolbar: true,\n                autoLink: false,\n                imageDragging: false,\n                disableExtraSpaces: true\n            }\n        );\n\n        const editor = document.getElementById( this.state.editorId );\n        editor.addEventListener( 'keydown', this.preventTabDefault );\n        editor.addEventListener( 'keyup', e => {\n            const predictableContainer = document.getElementById( this.state.predictableContainerId );\n            predictableContainer.style.display = 'none';\n\n            if ( predictableContainer &&\n                predictableContainer.firstChild &&\n                predictableContainer.firstChild.firstChild.data !== '' &&\n                e.key &&\n                e.key !== 'Backspace' &&\n                e.key !== 'Enter' &&\n                // Only check for suggested phrases if the user is typing at the end of the document.\n                this.isCaretAtEnd( editor )\n            ) {\n                const incompleteText = document.getSelection().anchorNode;\n\n                if ( incompleteText ) {\n                    const { top, left } = this.getLastWordCoordinates();\n                    // We create the visual effect of a placeholder element by overlaying the\n                    // suggestion container at the exact position of the incomplete text.\n                    predictableContainer.style.top = `${ top }px`;\n                    predictableContainer.style.left = `${ left }px`;\n                    predictableContainer.style.display = 'inline';\n                }\n            }\n        } );\n        editor.style.cssText = `\n            width: 826px;\n            min-height: 970px;\n            color: #333;\n            background-color: #fff;\n            margin-top: 100px;\n            margin-left: auto;\n            margin-right: auto;\n            overflow: hidden;\n            border-top: none;\n            padding-top: 80px;\n            padding-left: 96px!important;\n            padding-right: 96px!important;\n            border: 1px solid #80808082;\n            position: relative;\n            font-family: ${ this.state.font };\n            font-size: ${ this.state.fontSize };\n            letter-spacing: ${ this.state.letterSpacing };\n            line-height: 1.7rem;\n            outline: none;\n        `;\n\n        new Predictable( {\n            predictableContainerId: this.state.predictableContainerId,\n            editorId: this.state.editorId,\n            data: { source: words },\n            editor: editor,\n            sensitivity: 3,\n            predictableContainer: {\n                container: (source) => {\n                    source.setAttribute( 'id', this.state.predictableContainerId );\n                    source.style.cssText = `\n                        display: none;\n                        font-family: ${ this.state.font };\n                        font-size: ${ this.state.fontSize };\n                        letter-spacing: ${ this.state.letterSpacing };\n                        -webkit-user-modify: read-only;\n                        user-select: none;\n                        cursor: text;\n                        position: fixed;\n                        text-overflow: ellipsis;\n                        white-space: wrap;\n                        max-width: 320px;\n                        overflow: hidden;\n                        z-index: 99999;\n                        color: #757575;\n                        opacity: 0.7;\n                        overflow: hidden;\n                    `;\n                }\n            },\n            suggestionText: {\n                content: ({ match }, source) => {\n                    source.textContent = match;\n                }\n            },\n            context: {\n                getData: () => {\n                    this.getLastWordCoordinates();\n\n                    return this.getLastWord();\n                }\n            },\n            onTabPress: () => {\n                const incompleteText = document.getSelection().anchorNode,\n                    range = document.createRange();\n\n                range.selectNodeContents( incompleteText );\n\n                let _incompleteText = incompleteText;\n\n                if ( incompleteText.nodeType === 3 ) {\n                    _incompleteText = incompleteText.data;\n                } else {\n                    _incompleteText = incompleteText.textContent;\n                }\n\n                let autocompleteText = document.querySelector( '.predictable__suggestion' ).firstChild.data;\n                autocompleteText = autocompleteText.replace( _incompleteText, '' );\n\n                this.insertTextAtCursor( this.editorContainer.current, autocompleteText );\n            }\n        } );\n    }\n\n    componentWillUnmount() {\n        document.removeEventListener( 'keydown', this.preventTabDefault );\n    }\n\n    /**\n     * Renders an invisible `shadowNode` DOM element, positioned at the beginning of the last word.\n     *\n     * From here, `getBoundingClientRect` is called to obtain the top and left coordinates of the\n     * word, and are used to overlay the suggested word container in exactly the same position.\n     */\n    getLastWordCoordinates = () => {\n        const selection = window.getSelection(),\n            anchorNode = selection.anchorNode,\n            previousRange = selection.getRangeAt( 0 ),\n            lastWordOffset = this.getLastWordOffset( this.getLastWord() ),\n            range = document.createRange();\n\n        range.setStart( anchorNode, lastWordOffset );\n        range.setEnd( anchorNode, lastWordOffset );\n        range.collapse( false );\n\n        // Create a `shadowNode`, which is an invisible DOM node that allows the coordinates of the following\n        // word to be calculated.\n        const shadowNode = document.createElement( 'span' );\n        shadowNode.id = generateRandomId();\n        shadowNode.appendChild( document.createTextNode( '' ) );\n        range.insertNode( shadowNode );\n        selection.removeAllRanges();\n        selection.addRange( previousRange );\n\n        const { top, left } = shadowNode.getBoundingClientRect(),\n            parentNode = shadowNode.parentElement;\n\n        // Rejoins the text nodes which have been split by inserting the shadow node.\n        parentNode.normalize();\n        parentNode.removeChild( shadowNode );\n\n        return { top, left };\n    };\n\n    getLastWord = () => {\n        const selectedElement = window.getSelection().anchorNode;\n        if ( selectedElement && selectedElement.data ) return selectedElement.data;\n    };\n\n\n    getLastWordOffset = (text) => {\n        if ( text ) {\n            const words = text.split( ' ' );\n            const range = this.getLastWord();\n            const lastWordOfRange = words[ words.length - 1 ].trim();\n\n            // Returns the offset position of the last word.\n            return range.length - lastWordOfRange.length;\n        }\n\n        return 0;\n    };\n\n    isCaretAtEnd = (element) => {\n        let caretEndPosition = false,\n            selectionRange,\n            temporaryRange;\n\n        if ( window.getSelection ) {\n            const selection = window.getSelection();\n            if ( selection && selection.rangeCount ) {\n                selectionRange = selection.getRangeAt( 0 );\n                temporaryRange = selectionRange.cloneRange();\n\n                temporaryRange.selectNodeContents( element );\n                temporaryRange.setEnd( selectionRange.startContainer, selectionRange.startOffset );\n                temporaryRange.selectNodeContents( element );\n                temporaryRange.setStart( selectionRange.endContainer, selectionRange.endOffset );\n                caretEndPosition = ( temporaryRange.toString() === '' );\n            }\n        }\n\n        return caretEndPosition;\n    };\n\n    insertTextAtCursor = (editor, text) => {\n        let selection,\n            range;\n\n        if ( window.getSelection ) {\n            selection = window.getSelection();\n            if ( selection && selection.getRangeAt && selection.rangeCount ) {\n                range = selection.getRangeAt( 0 );\n                range.deleteContents();\n                range.insertNode( document.createTextNode( text ) );\n            }\n        }\n        // TODO: Fix issue with Firefox pushing caret to new paragraph\n        this.placeCaretAtEnd( editor );\n    };\n\n    placeCaretAtEnd = (editor) => {\n        if ( typeof window.getSelection !== 'undefined' && typeof document.createRange !== 'undefined' ) {\n            const range = document.createRange();\n            range.selectNodeContents( editor );\n            range.collapse( false );\n\n            const selection = window.getSelection();\n\n            if ( selection ) {\n                selection.removeAllRanges();\n                selection.addRange( range );\n            }\n        }\n    };\n\n    render() {\n        return (\n            <div className=\"App\">\n                <div\n                    id={ this.state.editorId }\n                    ref={ this.editorContainer }\n                />\n            </div>\n        );\n    }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render( <App />, document.getElementById( 'root' ) );\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}